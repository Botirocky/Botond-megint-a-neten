
<!DOCTYPE html>
<html lang="hu">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="default">
    <title>botondmegintaneten.hu</title>
    <meta name="description" content="Botond megint a neten ‚Äì etikus hekk, k√≥dok, tippek √©s el√©rhet≈ës√©g.">
    <meta property="og:title" content="botondmegintaneten.hu">
    <meta property="og:description" content="Etikus hekk √©s k√≥dok ‚Äì Botond megint a neten">
    <meta property="og:type" content="website">
    <meta property="og:url" content="/">
    <link rel="manifest" href="./manifest.webmanifest">
    <link rel="icon" href="/favicon.ico">
    <link rel="apple-touch-icon" href="/apple-touch-icon.png">
    <meta name="theme-color" content="#0b0f17">
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <header>
        <div class="header-inner">
        <div class="header-bg" aria-hidden="true"></div>
        <h1 class="logo-wave"><span>b</span><span>o</span><span>t</span><span>o</span><span>n</span><span>d</span><span>m</span><span>e</span><span>g</span><span>i</span><span>n</span><span>t</span><span>a</span><span>n</span><span>e</span><span>t</span><span>e</span><span>n</span><span>.</span><span>h</span><span>u</span></h1>
            <div class="controls">
                <button id="themeToggle" class="icon-btn" aria-label="T√©ma v√°lt√°sa" title="Vil√°gos/S√∂t√©t m√≥d">üåô</button>
                <button id="hamburger" class="icon-btn hamburger" aria-label="Men√º" title="Men√º">‚ò∞</button>
            </div>
            <nav>
                <ul id="mainNav">
                    <li><a href="#home">F≈ëoldal</a></li>
                    <li><a href="#about">R√≥lam</a></li>
                    <li><a href="#content">Tartalom</a></li>
                    <li><a href="#gallery">Gal√©ria</a></li>
                    <li><a href="#" class="snake-menu-link">Snake</a></li>
                    <li><a href="#tic-tac-toe">Am≈ëba</a></li>
                    <li><a href="#contact">El√©rhet≈ës√©g</a></li>
                </ul>
            </nav>
        </div>
    </header>
    <main class="container">
        <section id="home">
        <div class="hero">
          <div>
          <h2>F≈ëoldal</h2>
          <p class="muted">Az oldal fejleszt√©s alatt. K√©rem az esetleges hib√°kat jelezze az al√°bbi e‚Äëmail c√≠men.</p>
          </div>
          <div class="typing" aria-hidden="true">Itt lesz majd: <span id="typingTarget"></span><span class="cursor"></span></div>
        </div>
        </div>
        </section>
        <section id="about">
            <h2>R√≥lam</h2>
            <p>√údv, Botond vagyok. Szeretn√©m ha ez az oldal egy j√≥ gyakorl√°s lenne nekem √©s azon m√°s embereknek akik hozz√°m hasonl√≥an √©rdekl≈ëdnek a k√≥dol√°s √©s tech ir√°nt.
            Minden projektem megtal√°lod <a href="https://github.com/Botirocky" target="_blank" rel="noopener">Github-on.</a></p>
            <p>A Linktree-men megtal√°lod a tov√°bbi el√©rhet≈ës√©geim <a href="https://linktr.ee/Botirocky?utm_source=ig&utm_medium=social&utm_content=link_in_bio&fbclid=PAZXh0bgNhZW0CMTEAc3J0YwZhcHBfaWQMMjU2MjgxMDQwNTU4AAGnWQNl2-lInl7A3nWM9S7Xys6Ys8_gdXIOU9fBeKkBRAvNe1Qx08PTWVAqwew_aem_MPR7IXLgXqppxHNUVWi5Sg" target="_blank" rel="noopener">itt.</a></p>
        </section>
        <section id="content">
            <h2>Tartalom</h2>
        <div id="contentList" class="card-grid" aria-live="polite"></div>
        <template id="cardTpl">
          <a class="card" target="_blank" rel="noopener">
          <div class="card-inner">
            <div class="card-badges"></div>
            <div class="card-title"></div>
            <div class="card-meta"></div>
          </div>
          </a>
        </template>
        </section>
        <section id="gallery">
            <h2>P√©ldak√©peim</h2>
            <div class="gallery" id="galleryGrid">
                <!-- Place your images under html-ek/ or add external URLs below -->
                <img loading="lazy" src="https://cerebrodigital.net/wp-content/uploads/2025/09/portada-12.jpg" alt="Linus Torvalds" class="glight">
                <img loading="lazy" src="https://i.scdn.co/image/ab67616d0000b2737c8786f3c0b85ec3a60d011b" alt="Tecak" class="glight">
                <img loading="lazy" src="https://yt3.googleusercontent.com/ytc/AIdro_k2s1oV-ElOIvdSw3y-93nHW7TioYxFoWwF5i2um4PN-cs=s900-c-k-c0x00ffffff-no-rj" alt="Terry Davis" class="glight">
            </div>
        </section>
        <section id="contact">
            <h2>El√©rhet≈ës√©g</h2>
            <p>E‚Äëmail: <a id="emailLink" href="mailto:buczibotond@gmail.com">buczibotond@gmail.com</a>
                <button id="copyEmail" class="button" type="button">M√°sol√°s</button>
            </p>
        </section>
        <section id="snake-game" class="revealed" role="region" aria-labelledby="snake-title" style="--d: 400ms;">
            <h2 id="snake-title">J√°tssz Snake-et</h2>
            <div style="display: grid; grid-template-columns: 1fr; gap: 24px; max-width: 600px; margin: 0 auto;">
              <!-- Canvas -->
              <div style="display:flex; justify-content:center;">
                <canvas id="inlineSnakeCanvas" class="snake-canvas" width="400" height="400" aria-label="Snake j√°t√©k"></canvas>
              </div>

              <!-- Controls & Info -->
              <div style="display:flex; flex-direction:column; gap:16px;">
                <!-- Buttons -->
                <div style="display:flex; gap:8px; justify-content:center; flex-wrap:wrap;">
                  <button id="inlineSnakeStart" class="button" type="button" style="flex:1; min-width:80px;">‚ñ∂ Start</button>
                  <button id="inlineSnakePause" class="button" type="button" style="flex:1; min-width:80px;">‚è∏ Sz√ºnet</button>
                  <button id="inlineSnakeReset" class="button" type="button" style="flex:1; min-width:80px;">üîÑ √öjra</button>
                </div>

                <!-- Score Info -->
                <div style="display:grid; grid-template-columns:1fr 1fr; gap:12px; text-align:center;">
                  <div style="padding:12px; background:var(--surface); border-radius:8px; border:1px solid var(--border);">
                    <div style="font-size:12px; color:var(--muted); margin-bottom:4px;">PONT</div>
                    <div style="font-size:24px; font-weight:bold; color:var(--primary);"><span id="inlineSnakeScore">0</span></div>
                  </div>
                  <div style="padding:12px; background:var(--surface); border-radius:8px; border:1px solid var(--border);">
                    <div style="font-size:12px; color:var(--muted); margin-bottom:4px;">LEGJOBB</div>
                    <div style="font-size:20px; font-weight:bold; color:var(--primary);"><span id="inlineSnakeBest">0</span></div>
                    <div style="font-size:11px; color:var(--muted); margin-top:2px;"><span id="inlineSnakeBestName"></span></div>
                  </div>
                </div>

                <!-- Name Input -->
                <label for="inlineSnakeName" class="visually-hidden">N√©v a ranglist√°hoz</label>
                <input id="inlineSnakeName" type="text" placeholder="üíæ Add meg a neved" maxlength="15" aria-label="Neved a ranglist√°hoz" style="width:100%; padding:12px; border:1px solid var(--border); border-radius:8px; background:var(--bg); color:var(--text); font-size:14px;">

                <!-- Download Button -->
                <button id="inlineSnakeDownload" class="button" type="button" style="width:100%; padding:12px;">üì• Let√∂lt√©s (Logfile)</button>
              </div>
            </div>
        </section>
        <section id="tic-tac-toe" class="revealed" role="region" aria-labelledby="ttt-title" style="--d: 400ms;">
            <h2 id="ttt-title">Am≈ëba (Tic-Tac-Toe)</h2>
            <div class="ttt-wrap">
                <p class="ttt-status" id="tttStatus" aria-live="polite">X k√∂vetkezik</p>
                <div class="ttt-board" id="tttBoard" role="grid" aria-label="Am≈ëba t√°bla 3x3">
                    <button type="button" class="ttt-cell" data-i="0" aria-label="Mez≈ë 1"></button>
                    <button type="button" class="ttt-cell" data-i="1" aria-label="Mez≈ë 2"></button>
                    <button type="button" class="ttt-cell" data-i="2" aria-label="Mez≈ë 3"></button>
                    <button type="button" class="ttt-cell" data-i="3" aria-label="Mez≈ë 4"></button>
                    <button type="button" class="ttt-cell" data-i="4" aria-label="Mez≈ë 5"></button>
                    <button type="button" class="ttt-cell" data-i="5" aria-label="Mez≈ë 6"></button>
                    <button type="button" class="ttt-cell" data-i="6" aria-label="Mez≈ë 7"></button>
                    <button type="button" class="ttt-cell" data-i="7" aria-label="Mez≈ë 8"></button>
                    <button type="button" class="ttt-cell" data-i="8" aria-label="Mez≈ë 9"></button>
                </div>
                <button type="button" id="tttReset" class="button">√öj j√°t√©k</button>
            </div>
        </section>
    </main>
    <!-- Snake Modal -->
    <div id="snakeModal" class="snake-modal hidden" aria-hidden="true">
      <div class="snake-modal-backdrop"></div>
      <div class="snake-modal-content">
        <div class="snake-modal-header">
          <h2>Snake J√°t√©k</h2>
          <button id="snakeModalClose" class="icon-btn" aria-label="Bez√°r√°s">‚úï</button>
        </div>
        <div class="snake-modal-body">
          <div class="snake-header">
            <strong>J√°t√©kt√°bla</strong>
            <div>
              <button id="startSnake" class="button" type="button">Start</button>
              <button id="snakeRestart" class="button" type="button">√öjra</button>
              <button id="snakeResetBest" class="button" type="button">Reset Legjobb</button>
            </div>
        </div>
        <div class="canvas-wrapper"><canvas id="snakeCanvas" class="snake-canvas"></canvas></div>
        <div class="snake-controls" id="snakeControls">
          <button class="snake-up" aria-label="Fel">‚ñ≤</button>
          <div class="snake-dpad">
            <button class="snake-left" aria-label="Bal">‚óÑ</button>
            <button class="snake-down" aria-label="Le">‚ñº</button>
            <button class="snake-right" aria-label="Jobbra">‚ñ∫</button>
          </div>
        </div>
        <div class="snake-footer">
          <span id="snakeScore">Pont: 0</span>
          <span id="snakeBest" class="muted">Legjobb: 0</span>
          <span id="snakeStatus" class="muted"></span>
        </div>
        <div class="snake-leaderboard" aria-live="polite">
          <h4>Ranglista</h4>
          <ol id="snakeBoard"></ol>
          <button id="snakeClearBoard" class="button snake-clear" type="button">T√∂r√∂l ranglist√°t</button>
        </div>
        <form id="snakeEntryForm" class="snake-entry snake-entry hidden" onsubmit="return false;" aria-hidden="true">
          <div class="snake-entry-inner">
            <label for="snakeName">Neved a ranglist√°hoz:</label>
            <input id="snakeName" type="text" placeholder="Pl. Boti" aria-label="N√©v" autofocus />
          </div>
          <div class="snake-entry-buttons">
            <button id="snakeSaveEntry" class="button btn-primary" type="button">‚úì Ment√©s</button>
            <button id="snakeCancelEntry" class="button" type="button">‚úï M√©gse</button>
          </div>
        </form>
      </div>
    </div>
    <button id="toTop" aria-label="Vissza a tetej√©re" title="Vissza a tetej√©re">‚Üë</button>
    <footer>
        <p>&copy; 2025 Buczi Botond. Minden jog fenntartva.</p>
    </footer>

    <script>
    // Theme initialize from system/localStorage
    (function initTheme(){
      const stored = localStorage.getItem('theme');
      const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
      if (stored === 'dark' || (!stored && prefersDark)) document.documentElement.classList.add('dark');
    })();

    // Register service worker
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('./service-worker.js');
      });
    }

    // Dark mode toggle
    const themeBtn = document.getElementById('themeToggle');
    themeBtn.addEventListener('click', () => {
      const isDark = document.documentElement.classList.toggle('dark');
      localStorage.setItem('theme', isDark ? 'dark' : 'light');
      themeBtn.textContent = isDark ? '‚òÄÔ∏è' : 'üåô';
      // microanimation
      themeBtn.classList.add('spin');
      setTimeout(() => themeBtn.classList.remove('spin'), 400);
    });
    // Set initial icon
    themeBtn.textContent = document.documentElement.classList.contains('dark') ? '‚òÄÔ∏è' : 'üåô';

    // Mobile nav toggle
    const hamburger = document.getElementById('hamburger');
    const mainNav = document.getElementById('mainNav');
    hamburger.addEventListener('click', () => {
      mainNav.classList.toggle('open');
    });
    // Close nav on link click (mobile)
    mainNav.querySelectorAll('a').forEach(a => a.addEventListener('click', () => mainNav.classList.remove('open')));

    // Smooth scroll with offset for sticky header
    function scrollWithOffset(hash) {
      const el = document.querySelector(hash);
      if (!el) return;
      const y = el.getBoundingClientRect().top + window.scrollY - 70; // header height approx
      window.scrollTo({ top: y, behavior: 'smooth' });
    }
    document.querySelectorAll('a[href^="#"]').forEach(a => {
      a.addEventListener('click', (e) => {
        const href = a.getAttribute('href');
        if (href.length > 1) {
          e.preventDefault();
          history.pushState(null, '', href);
          scrollWithOffset(href);
        }
      });
    });

    // Scroll to top button
    const toTop = document.getElementById('toTop');
    const onScroll = () => {
      const sections = document.querySelectorAll('main section');
      let currentId = '';
      const offset = 80;
      sections.forEach(sec => {
        const top = sec.offsetTop - offset;
        if (window.scrollY >= top) currentId = sec.id;
      });
      document.querySelectorAll('#mainNav a').forEach(a => {
        const active = a.getAttribute('href') === '#' + currentId;
        a.classList.toggle('active', active);
      });
      if (window.scrollY > 200) toTop.classList.add('show'); else toTop.classList.remove('show');
    };
    window.addEventListener('scroll', onScroll, { passive: true });
    toTop.addEventListener('click', () => window.scrollTo({ top: 0, behavior: 'smooth' }));
    onScroll();

    // Reveal sections on view with staggered delays
    const io = new IntersectionObserver((entries) => {
      entries.forEach(e => { if (e.isIntersecting) { e.target.classList.add('revealed'); io.unobserve(e.target); } });
    }, { threshold: 0.08 });
    const sectionsToReveal = document.querySelectorAll('section');
    sectionsToReveal.forEach((sec, i) => {
      sec.style.setProperty('--d', `${i * 80}ms`);
      io.observe(sec);
    });

    // Copy email to clipboard
    document.getElementById('copyEmail').addEventListener('click', async () => {
      const email = 'buczibotond@gmail.com';
      try {
        await navigator.clipboard.writeText(email);
        const btn = document.getElementById('copyEmail');
        const old = btn.textContent;
        btn.textContent = 'M√°solva!';
        setTimeout(() => btn.textContent = old, 1500);
      } catch (e) {
        alert('Nem siker√ºlt m√°solni. E‚Äëmail: ' + email);
      }
    });

    // Build Content list from html-ek/ directory using fetch of directory index (works when server exposes listing)
    async function buildContentList() {
      const root = document.getElementById('contentList');
      if (!root) return;
      const base = 'html-ek/';
      const badgeMap = [
        { test: /gal[e√©]ria|gallery|kep|image/i, label: 'gal√©ria' },
        { test: /blog|cikk|article|post/i, label: 'blog' },
        { test: /projekt|project|code|k[o√≥]d/i, label: 'projekt' },
        { test: /teszt|demo|example/i, label: 'demo' },
      ];
      try {
        const res = await fetch(base);
        const text = await res.text();
        const links = Array.from(text.matchAll(/href=\"([^\"]+)\"/g)).map(m => m[1])
          .filter(h => h.endsWith('.html'));
        const unique = [...new Set(links)].sort((a,b) => a.localeCompare(b));
        if (unique.length === 0) throw new Error('No index');
        const tpl = document.getElementById('cardTpl');
        root.innerHTML = '';
        unique.forEach(h => {
          const url = base + h;
          const name = h.replace(/[-_]/g, ' ').replace(/\.html$/,'');
          const node = tpl.content.firstElementChild.cloneNode(true);
          node.href = url;
          node.querySelector('.card-title').textContent = name;
          node.querySelector('.card-meta').textContent = `html-ek/${h}`;
          const badges = node.querySelector('.card-badges');
          const matched = badgeMap.find(b => b.test.test(h));
          const badge = document.createElement('span');
          badge.className = 'badge';
          badge.textContent = matched ? matched.label : 'oldal';
          // add subtle pulse randomly
          if (Math.random() > 0.6) badge.classList.add('pulse');
          badges.appendChild(badge);
          root.appendChild(node);
        });
      } catch (err) {
        // Fallback: list a hint card
        root.innerHTML = `<div class="card hint"></div>`;
      }
    }
    buildContentList();

    // Lightbox for gallery
    (function lightbox(){
      const imgs = document.querySelectorAll('.glight');
      if (!imgs.length) return;
      const overlay = document.createElement('div');
      overlay.className = 'lightbox';
      overlay.innerHTML = '<button class="close" aria-label="Bez√°r√°s">‚úï</button><img alt="Megnyitott k√©p">';
      document.body.appendChild(overlay);
      const imgTag = overlay.querySelector('img');
      const closeBtn = overlay.querySelector('.close');
      function open(src, alt){ imgTag.src = src; imgTag.alt = alt || ''; overlay.classList.add('show'); }
      function close(){ overlay.classList.remove('show'); imgTag.src=''; imgTag.alt=''; }
      imgs.forEach(i => i.addEventListener('click', () => open(i.src, i.alt)));
      overlay.addEventListener('click', (e) => { if (e.target === overlay) close(); });
      closeBtn.addEventListener('click', close);
      document.addEventListener('keydown', (e) => { if (e.key === 'Escape') close(); });
    })();

    // Ripple effect on buttons
    (function attachRipples(){
      function createRipple(e){
        const el = e.currentTarget;
        const rect = el.getBoundingClientRect();
        const size = Math.max(rect.width, rect.height) * 1.2;
        const span = document.createElement('span');
        span.className = 'ripple';
        span.style.width = span.style.height = size + 'px';
        span.style.left = (e.clientX - rect.left - size/2) + 'px';
        span.style.top = (e.clientY - rect.top - size/2) + 'px';
        el.appendChild(span);
        span.addEventListener('animationend', () => span.remove());
      }
      document.querySelectorAll('.button, .icon-btn').forEach(btn => {
        btn.addEventListener('click', createRipple);
      });
    })();

    // Typing effect for hero
    (function typingEffect(){
      const el = document.getElementById('typingTarget');
      if (!el) return;
      const phrases = ['projektek', '√©rdekess√©gek', 'k√≥dmint√°k', 'mini demo-k', 'blog bejegyz√©sek'];
      let pi = 0, ci = 0, deleting = false;
      function step(){
        const cur = phrases[pi];
        if (!deleting) {
          el.textContent = cur.slice(0, ci+1);
          ci++;
          if (ci >= cur.length) { deleting = true; setTimeout(step, 1200); return; }
        } else {
          el.textContent = cur.slice(0, ci-1);
          ci--;
          if (ci <= 0) { deleting = false; pi = (pi+1) % phrases.length; }
        }
        setTimeout(step, deleting ? 70 : 90);
      }
      step();
    })();

    // 3D tilt for cards
    function attachCardTilt(){
      document.querySelectorAll('.card').forEach(card => {
        const inner = card.querySelector('.card-inner') || card;
        function onMove(e){
          const rect = card.getBoundingClientRect();
          const x = (e.clientX - rect.left) / rect.width - 0.5;
          const y = (e.clientY - rect.top) / rect.height - 0.5;
          const rotX = (-y) * 6;
          const rotY = (x) * 10;
          inner.style.transform = `rotateX(${rotX}deg) rotateY(${rotY}deg) translateZ(6px)`;
          card.classList.add('tilt');
        }
        function onLeave(){ inner.style.transform = ''; card.classList.remove('tilt'); }
        card.addEventListener('mousemove', onMove);
        card.addEventListener('mouseleave', onLeave);
      });
    }
    attachCardTilt();

    // Drag-to-scroll gallery
    (function dragGallery(){
      const gallery = document.getElementById('galleryGrid');
      if (!gallery) return;
      let isDown=false, startX, scrollLeft;
      gallery.addEventListener('mousedown', (e)=>{
        isDown = true; gallery.classList.add('dragging'); startX = e.pageX - gallery.offsetLeft; scrollLeft = gallery.scrollLeft; e.preventDefault();
      });
      gallery.addEventListener('mouseleave', ()=>{ isDown=false; gallery.classList.remove('dragging'); });
      gallery.addEventListener('mouseup', ()=>{ isDown=false; gallery.classList.remove('dragging'); });
      gallery.addEventListener('mousemove', (e)=>{
        if(!isDown) return; const x = e.pageX - gallery.offsetLeft; const walk = (x - startX) * 1.2; gallery.scrollLeft = scrollLeft - walk;
      });
      // touch support
      gallery.addEventListener('touchstart', (e)=>{ startX = e.touches[0].pageX - gallery.offsetLeft; scrollLeft = gallery.scrollLeft; });
      gallery.addEventListener('touchmove', (e)=>{ e.preventDefault(); const x = e.touches[0].pageX - gallery.offsetLeft; const walk = (x - startX) * 1.2; gallery.scrollLeft = scrollLeft - walk; }, { passive: false });
    })();

    // Header parallax on mousemove
    (function headerParallax(){
      const hdr = document.querySelector('.header-inner');
      const bg = document.querySelector('.header-bg');
      if (!hdr || !bg) return;
      hdr.addEventListener('mousemove', (e)=>{
        const r = hdr.getBoundingClientRect();
        const x = (e.clientX - r.left) / r.width - 0.5;
        const y = (e.clientY - r.top) / r.height - 0.5;
        const tx = x * 18; const ty = y * 8;
        bg.style.transform = `translate3d(${tx}px, ${ty}px, 0)`;
      });
      hdr.addEventListener('mouseleave', ()=>{ bg.style.transform = ''; });
    })();

    // Simple confetti burst at coordinates
    function confettiBurst(x,y){
      const container = document.createElement('div');
      container.className = 'confetti';
      container.style.left = '0'; container.style.top = '0';
      document.body.appendChild(container);
      const colors = ['#ff4d4f','#ffd166','#06d6a0','#4d7cff','#d16cff'];
      for(let i=0;i<18;i++){
        const p = document.createElement('div'); p.className = 'p';
        const w = 6 + Math.round(Math.random()*10);
        p.style.width = w + 'px'; p.style.height = (w+4) + 'px';
        p.style.background = colors[Math.floor(Math.random()*colors.length)];
        p.style.left = (x + (Math.random()-0.5)*80) + 'px';
        p.style.top = (y + (Math.random()-0.5)*30) + 'px';
        p.style.transform = `translate3d(0,0,0) rotate(${Math.random()*360}deg)`;
        container.appendChild(p);
        // animate
        const dx = (Math.random()-0.5) * 300;
        const dy = 200 + Math.random()*200;
        const rot = (Math.random()-0.5)*720;
        requestAnimationFrame(()=>{
          p.style.transition = 'transform 900ms cubic-bezier(.2,.8,.2,1), opacity 900ms ease';
          p.style.transform = `translate3d(${dx}px, ${dy}px, 0) rotate(${rot}deg)`;
          p.style.opacity = '0';
        });
      }
      setTimeout(()=> container.remove(), 1200);
    }

    // Trigger confetti on copy and keyboard shortcuts
    const copyBtn = document.getElementById('copyEmail');
    if (copyBtn) {
      copyBtn.addEventListener('click', (e) => {
        const rect = copyBtn.getBoundingClientRect();
        confettiBurst(rect.left + rect.width/2, rect.top + rect.height/2);
      });
    }

    // Keyboard shortcuts: 't' toggle theme, 'g' go to gallery
    document.addEventListener('keydown', (e) => {
      if (e.target && (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA')) return;
      if (e.key === 't') { themeBtn.click(); }
      if (e.key === 'g') { scrollWithOffset('#gallery'); }
    });

    // Snake game logic (simplified & robust) + leaderboard
    (function snakeGame(){
      const startBtn   = document.getElementById('startSnake');
      const restartBtn = document.getElementById('snakeRestart');
      const resetBtn   = document.getElementById('snakeResetBest');
      const canvas     = document.getElementById('snakeCanvas');
      const scoreEl    = document.getElementById('snakeScore');
      const bestEl     = document.getElementById('snakeBest');
      const statusEl   = document.getElementById('snakeStatus');
      const boardEl    = document.getElementById('snakeBoard');
      const clearBoardBtn = document.getElementById('snakeClearBoard');
      const entryForm  = document.getElementById('snakeEntryForm');
      const nameInput  = document.getElementById('snakeName');
      const saveEntryBtn   = document.getElementById('snakeSaveEntry');
      const cancelEntryBtn = document.getElementById('snakeCancelEntry');

      if (!canvas || !startBtn || !scoreEl || !bestEl || !statusEl) {
        return;
      }

      const ctx = canvas.getContext('2d');

      const GRID_SIZE   = 16;
      const TICK_MS     = 220;
      let tileSize      = 20;

      let snake   = [];
      let dir     = { x: 1, y: 0 };
      let nextDir = { x: 1, y: 0 };
      let food    = null;
      let score   = 0;
      let best    = 0;
      let loopId  = null;
      let running = false;
      let leaderboard = [];
      let pendingScore = null;

      // Best score persistence
      (function loadBest(){
        try {
          const raw = localStorage.getItem('snake_best_v2');
          if (!raw) return;
          const parsed = JSON.parse(raw);
          if (parsed && typeof parsed.score === 'number') {
            best = parsed.score;
          }
        } catch(e){}
      })();

      // Leaderboard persistence (top 5)
      (function loadLeaderboard(){
        try {
          const raw = localStorage.getItem('snake_board_v1');
          if (!raw) return;
          const parsed = JSON.parse(raw);
          if (Array.isArray(parsed)) {
            leaderboard = parsed
              .filter(e => typeof e.score === 'number')
              .sort((a, b) => b.score - a.score)
              .slice(0, 5);
            renderLeaderboard();
          }
        } catch(e){}
      })();

      function saveBest(){
        try {
          localStorage.setItem('snake_best_v2', JSON.stringify({ score: best }));
        } catch(e){}
      }

      function saveLeaderboard(){
        try {
          localStorage.setItem('snake_board_v1', JSON.stringify(leaderboard));
        } catch(e){}
      }

      function renderLeaderboard(){
        if (!boardEl) return;
        boardEl.innerHTML = '';
        leaderboard.forEach(entry => {
          const li = document.createElement('li');
          const nameSpan = document.createElement('span');
          nameSpan.className = 'name';
          nameSpan.textContent = entry.name || 'Ismeretlen';
          const metaSpan = document.createElement('span');
          metaSpan.className = 'meta';
          const date = entry.date ? ' ¬∑ ' + entry.date : '';
          metaSpan.textContent = `${entry.score} pont${date}`;
          li.appendChild(nameSpan);
          li.appendChild(metaSpan);
          boardEl.appendChild(li);
        });
      }

      function showEntryForm(finalScore){
        if (!entryForm || !nameInput) return;
        pendingScore = finalScore;
        entryForm.classList.remove('hidden');
        entryForm.setAttribute('aria-hidden', 'false');
        if (!nameInput.value) nameInput.value = '';
        nameInput.focus();
      }

      function hideEntryForm(){
        if (!entryForm) return;
        entryForm.classList.add('hidden');
        entryForm.setAttribute('aria-hidden', 'true');
        pendingScore = null;
      }

      function updateScore(){
        scoreEl.textContent = 'Pont: ' + score;
        if (score > best) {
          best = score;
          saveBest();
          bestEl.textContent = 'Legjobb: ' + best;
          const r = canvas.getBoundingClientRect();
          confettiBurst(r.left + r.width/2, r.top + r.height/2);
        } else {
          bestEl.textContent = 'Legjobb: ' + best;
        }
      }

      function resizeCanvas(){
        const rect = canvas.parentElement.getBoundingClientRect();
        const size = Math.min(rect.width, 400);
        canvas.width  = size;
        canvas.height = size;
        tileSize = size / GRID_SIZE;
        draw();
      }

      function randomFreeCell(){
        while (true) {
          const x = Math.floor(Math.random() * GRID_SIZE);
          const y = Math.floor(Math.random() * GRID_SIZE);
          if (!snake.some(s => s.x === x && s.y === y)) return { x, y };
        }
      }

      function init(){
        const mid = Math.floor(GRID_SIZE / 2);
        snake = [
          { x: mid,     y: mid },
          { x: mid - 1, y: mid },
          { x: mid - 2, y: mid }
        ];
        dir     = { x: 1, y: 0 };
        nextDir = { x: 1, y: 0 };
        food    = randomFreeCell();
        score   = 0;
        running = false;
        statusEl.textContent = '';
        statusEl.classList.remove('snake-lose');
        updateScore();
        draw();
      }

      function draw(){
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // background
        ctx.fillStyle = '#0f172a';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // grid
        ctx.strokeStyle = 'rgba(148, 163, 184, 0.2)';
        ctx.lineWidth = 1;
        for (let i = 0; i <= GRID_SIZE; i++) {
          const p = i * tileSize;
          ctx.beginPath();
          ctx.moveTo(p, 0);
          ctx.lineTo(p, canvas.height);
          ctx.stroke();

          ctx.beginPath();
          ctx.moveTo(0, p);
          ctx.lineTo(canvas.width, p);
          ctx.stroke();
        }

        // food
        if (food) {
          ctx.fillStyle = '#f97316';
          const fx = food.x * tileSize + tileSize / 2;
          const fy = food.y * tileSize + tileSize / 2;
          ctx.beginPath();
          ctx.arc(fx, fy, tileSize * 0.35, 0, Math.PI * 2);
          ctx.fill();
        }

        // snake
        snake.forEach((seg, idx) => {
          const hue = 140;
          const light = 45 + (idx / snake.length) * 20;
          ctx.fillStyle = `hsl(${hue}, 70%, ${light}%)`;
          ctx.fillRect(
            seg.x * tileSize + 2,
            seg.y * tileSize + 2,
            tileSize - 4,
            tileSize - 4
          );

          if (idx === 0) {
            ctx.strokeStyle = `hsl(${hue}, 95%, 80%)`;
            ctx.lineWidth = 2;
            ctx.strokeRect(
              seg.x * tileSize + 2,
              seg.y * tileSize + 2,
              tileSize - 4,
              tileSize - 4
            );
          }
        });
      }

      function step(){
        if (!running) return;

        dir = nextDir;
        const head = {
          x: snake[0].x + dir.x,
          y: snake[0].y + dir.y
        };

        // wall collision
        if (
          head.x < 0 || head.x >= GRID_SIZE ||
          head.y < 0 || head.y >= GRID_SIZE
        ) {
          return gameOver();
        }

        // self collision
        if (snake.some(seg => seg.x === head.x && seg.y === head.y)) {
          return gameOver();
        }

        snake.unshift(head);

        if (food && head.x === food.x && head.y === food.y) {
          score++;
          updateScore();
          food = randomFreeCell();
        } else {
          snake.pop();
        }

        draw();
      }

      function gameOver(){
        running = false;
        if (loopId) clearInterval(loopId);
        loopId = null;
        statusEl.textContent = 'Vesztett√©l!';
        statusEl.classList.add('snake-lose');
        if (score > 0) {
          showEntryForm(score);
        }
      }

      function startGame(){
        if (running) return;
        running = true;
        statusEl.textContent = '';
        if (loopId) clearInterval(loopId);
        loopId = setInterval(step, TICK_MS);
      }

      function restartGame(){
        if (loopId) clearInterval(loopId);
        loopId = null;
        init();
        startGame();
      }

      // keyboard controls
      document.addEventListener('keydown', (e) => {
        const k = e.key;
        if (k === 'ArrowUp' || k === 'w')  { if (dir.y !== 1)  nextDir = { x: 0,  y: -1 }; }
        if (k === 'ArrowDown' || k === 's'){ if (dir.y !== -1) nextDir = { x: 0,  y: 1  }; }
        if (k === 'ArrowLeft' || k === 'a'){ if (dir.x !== 1)  nextDir = { x: -1, y: 0  }; }
        if (k === 'ArrowRight' || k === 'd'){ if (dir.x !== -1) nextDir = { x: 1,  y: 0  }; }
      });

      // touch controls (D‚Äëpad)
      const upBtn    = document.querySelector('.snake-up');
      const downBtn  = document.querySelector('.snake-down');
      const leftBtn  = document.querySelector('.snake-left');
      const rightBtn = document.querySelector('.snake-right');

      if (upBtn)    upBtn.addEventListener('click',   () => { if (dir.y !== 1)  nextDir = { x: 0,  y: -1 }; });
      if (downBtn)  downBtn.addEventListener('click', () => { if (dir.y !== -1) nextDir = { x: 0,  y: 1  }; });
      if (leftBtn)  leftBtn.addEventListener('click', () => { if (dir.x !== 1)  nextDir = { x: -1, y: 0  }; });
      if (rightBtn) rightBtn.addEventListener('click',() => { if (dir.x !== -1) nextDir = { x: 1,  y: 0  }; });

      // buttons
      startBtn.addEventListener('click', startGame);
      if (restartBtn) restartBtn.addEventListener('click', restartGame);
      if (resetBtn) {
        resetBtn.addEventListener('click', () => {
          best = 0;
          saveBest();
          bestEl.textContent = 'Legjobb: 0';
        });
      }

      if (saveEntryBtn) {
        saveEntryBtn.addEventListener('click', () => {
          if (pendingScore == null) {
            hideEntryForm();
            return;
          }
          const name = (nameInput && nameInput.value.trim()) || 'Ismeretlen';
          const entry = {
            name,
            score: pendingScore,
            date: new Date().toLocaleString('hu-HU')
          };
          leaderboard.push(entry);
          leaderboard.sort((a, b) => b.score - a.score);
          leaderboard = leaderboard.slice(0, 5);
          saveLeaderboard();
          renderLeaderboard();
          hideEntryForm();
        });
      }

      if (cancelEntryBtn) {
        cancelEntryBtn.addEventListener('click', () => {
          hideEntryForm();
        });
      }

      if (clearBoardBtn) {
        clearBoardBtn.addEventListener('click', () => {
          leaderboard = [];
          saveLeaderboard();
          if (boardEl) boardEl.innerHTML = '';
        });
      }

      window.addEventListener('resize', resizeCanvas);

      // init
      init();
      resizeCanvas();
    })();

    // Snake Modal Handlers
    (function() {
      const modal = document.getElementById('snakeModal');
      const snakeMenuLink = document.querySelector('.snake-menu-link');
      const closeBtn = document.getElementById('snakeModalClose');
      const backdrop = document.querySelector('.snake-modal-backdrop');

      function openModal() {
        if (!modal) return;
        modal.classList.remove('hidden');
        modal.setAttribute('aria-hidden', 'false');
        // Auto-start the Snake game and ensure the canvas is properly sized
        try {
          const startBtn = document.getElementById('startSnake');
          if (startBtn) {
            startBtn.click();
          }
          // Force a resize so the Snake canvas recalculates its dimensions
          window.dispatchEvent(new Event('resize'));
        } catch (e) {}
      }

      function closeModal() {
        if (!modal) return;
        modal.classList.add('hidden');
        modal.setAttribute('aria-hidden', 'true');
      }

      if (snakeMenuLink) {
        snakeMenuLink.addEventListener('click', (e) => {
          e.preventDefault();
          openModal();
        });
      }

      if (closeBtn) {
        closeBtn.addEventListener('click', closeModal);
      }

      if (backdrop) {
        backdrop.addEventListener('click', closeModal);
      }

      // Close on Escape key
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && modal && !modal.classList.contains('hidden')) {
          closeModal();
        }
      });
    })();

    // Inline Snake Game
    (function() {
      const canvas = document.getElementById('inlineSnakeCanvas');
      const scoreDisplay = document.getElementById('inlineSnakeScore');
      const bestDisplay = document.getElementById('inlineSnakeBest');
      const bestNameDisplay = document.getElementById('inlineSnakeBestName');
      const nameInput = document.getElementById('inlineSnakeName');
      const startBtn = document.getElementById('inlineSnakeStart');
      const pauseBtn = document.getElementById('inlineSnakePause');
      const resetBtn = document.getElementById('inlineSnakeReset');
      const downloadBtn = document.getElementById('inlineSnakeDownload');

      if (!canvas || !startBtn || !pauseBtn || !resetBtn) {
        console.error('Snake game elements missing');
        return;
      }

      const ctx = canvas.getContext('2d');
      const GRID_SIZE = 6;
      let TILE_SIZE = 400 / GRID_SIZE;
      
      function randomFreeCell(snakeArr) {
        let pos;
        do {
          pos = { x: Math.floor(Math.random() * GRID_SIZE), y: Math.floor(Math.random() * GRID_SIZE) };
        } while (snakeArr.some(s => s.x === pos.x && s.y === pos.y));
        return pos;
      }
      
      let snake = [{x: 3, y: 3}, {x: 2, y: 3}, {x: 1, y: 3}, {x: 0, y: 3}];
      let food = randomFreeCell(snake);
      let direction = {x: 1, y: 0};
      let nextDirection = {x: 1, y: 0};
      let score = 0;
      let best = 0;
      let bestName = '';
      let running = false;
      let paused = false;
      let gameLoop = null;

      // Load best score from localStorage
      function loadBest() {
        try {
          const data = JSON.parse(localStorage.getItem('inlineSnakeBestData') || '{"name":"","score":0}');
          best = data.score || 0;
          bestName = data.name || '';
        } catch (e) {}
        updateBestDisplay();
      }

      function updateBestDisplay() {
        if (bestDisplay) bestDisplay.textContent = best;
        if (bestNameDisplay) bestNameDisplay.textContent = bestName ? `(${bestName})` : '';
      }

      function saveBest(name) {
        try {
          localStorage.setItem('inlineSnakeBestData', JSON.stringify({name, score: best}));
          bestName = name;
          updateBestDisplay();
          saveToLog(name, best);
        } catch (e) {}
      }

      function saveToLog(name, points) {
        try {
          const log = JSON.parse(localStorage.getItem('inlineSnakeLog') || '[]');
          const date = new Date().toLocaleString('hu-HU');
          log.push({name, points, date});
          localStorage.setItem('inlineSnakeLog', JSON.stringify(log));
        } catch (e) {}
      }

      function downloadLog() {
        try {
          const log = JSON.parse(localStorage.getItem('inlineSnakeLog') || '[]');
          let content = 'SNAKE GAME LOG\n==============\n\n';
          if (log.length === 0) {
            content += 'Nincs m√©g mentett eredm√©ny.\n';
          } else {
            log.forEach((entry, i) => {
              content += `${i + 1}. ${entry.name || 'Ismeretlen'} - ${entry.points} pont - ${entry.date}\n`;
            });
          }
          const blob = new Blob([content], {type: 'text/plain'});
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = `snake_log_${new Date().getTime()}.txt`;
          a.click();
          URL.revokeObjectURL(url);
        } catch (e) {
          console.error('Download failed:', e);
        }
      }

      function draw() {
        ctx.fillStyle = '#1a1a2e';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Grid lines
        ctx.strokeStyle = 'rgba(77, 124, 255, 0.15)';
        ctx.lineWidth = 1;
        for (let i = 0; i <= GRID_SIZE; i++) {
          ctx.beginPath();
          ctx.moveTo(i * TILE_SIZE, 0);
          ctx.lineTo(i * TILE_SIZE, canvas.height);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(0, i * TILE_SIZE);
          ctx.lineTo(canvas.width, i * TILE_SIZE);
          ctx.stroke();
        }

        // Food
        ctx.fillStyle = '#ff6b6b';
        ctx.beginPath();
        ctx.arc(food.x * TILE_SIZE + TILE_SIZE / 2, food.y * TILE_SIZE + TILE_SIZE / 2, TILE_SIZE / 2.5, 0, Math.PI * 2);
        ctx.fill();

        // Snake
        snake.forEach((segment, idx) => {
          const hue = 220;
          const brightness = 50 + (idx / snake.length) * 20;
          ctx.fillStyle = `hsl(${hue}, 75%, ${brightness}%)`;
          ctx.fillRect(segment.x * TILE_SIZE + 2, segment.y * TILE_SIZE + 2, TILE_SIZE - 4, TILE_SIZE - 4);
          
          if (idx === 0) {
            ctx.strokeStyle = `hsl(${hue}, 100%, 70%)`;
            ctx.lineWidth = 2;
            ctx.strokeRect(segment.x * TILE_SIZE + 2, segment.y * TILE_SIZE + 2, TILE_SIZE - 4, TILE_SIZE - 4);
          }
        });
      }

      function update() {
        if (paused || !running) return;
        
        direction = nextDirection;
        const head = {x: snake[0].x + direction.x, y: snake[0].y + direction.y};

        // Boundary check
        if (head.x < 0 || head.x >= GRID_SIZE || head.y < 0 || head.y >= GRID_SIZE) {
          gameOver();
          return;
        }

        // Self collision
        if (snake.some(s => s.x === head.x && s.y === head.y)) {
          gameOver();
          return;
        }

        snake.unshift(head);

        // Food collision
        if (head.x === food.x && head.y === food.y) {
          score++;
          if (scoreDisplay) scoreDisplay.textContent = score;
          food = randomFreeCell(snake);
        } else {
          snake.pop();
        }

        draw();
      }

      function gameOver() {
        running = false;
        clearInterval(gameLoop);
        if (score > best) {
          best = score;
          const name = (nameInput && nameInput.value.trim()) || 'Ismeretlen';
          saveBest(name);
        }
        startBtn.textContent = '‚ñ∂ Start';
      }

      function start() {
        if (running) return;
        running = true;
        paused = false;
        startBtn.textContent = '‚ñ∂ Folytat√°s';
        if (pauseBtn) pauseBtn.textContent = '‚è∏ Sz√ºnet';
        gameLoop = setInterval(update, 170);
      }

      function togglePause() {
        if (!running) return;
        paused = !paused;
        if (pauseBtn) {
          pauseBtn.textContent = paused ? '‚ñ∂ Folytat√°s' : '‚è∏ Sz√ºnet';
        }
      }

      function reset() {
        clearInterval(gameLoop);
        snake = [{x: 3, y: 3}, {x: 2, y: 3}, {x: 1, y: 3}, {x: 0, y: 3}];
        food = randomFreeCell(snake);
        direction = {x: 1, y: 0};
        nextDirection = {x: 1, y: 0};
        score = 0;
        if (scoreDisplay) scoreDisplay.textContent = '0';
        running = false;
        paused = false;
        startBtn.textContent = '‚ñ∂ Start';
        if (pauseBtn) pauseBtn.textContent = '‚è∏ Sz√ºnet';
        draw();
      }

      // Event listeners
      startBtn.addEventListener('click', () => {
        if (!running) start();
        else togglePause();
      });

      pauseBtn.addEventListener('click', togglePause);
      resetBtn.addEventListener('click', reset);

      if (downloadBtn) {
        downloadBtn.addEventListener('click', downloadLog);
      }

      // Keyboard controls
      document.addEventListener('keydown', (e) => {
        if (!running) return;
        if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') {
          e.preventDefault();
          if (direction.y === 0) nextDirection = {x: 0, y: -1};
        }
        if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') {
          e.preventDefault();
          if (direction.y === 0) nextDirection = {x: 0, y: 1};
        }
        if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') {
          e.preventDefault();
          if (direction.x === 0) nextDirection = {x: -1, y: 0};
        }
        if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') {
          e.preventDefault();
          if (direction.x === 0) nextDirection = {x: 1, y: 0};
        }
      });

      // Touch controls
      canvas.addEventListener('touchstart', (e) => {
        if (!running) return;
        const touch = e.touches[0];
        const rect = canvas.getBoundingClientRect();
        const x = touch.clientX - rect.left;
        const y = touch.clientY - rect.top;
        const centerX = rect.width / 2;
        const centerY = rect.height / 2;
        const dx = x - centerX;
        const dy = y - centerY;

        if (Math.abs(dx) > Math.abs(dy)) {
          if (dx > 0 && direction.x === 0) nextDirection = {x: 1, y: 0};
          else if (dx < 0 && direction.x === 0) nextDirection = {x: -1, y: 0};
        } else {
          if (dy > 0 && direction.y === 0) nextDirection = {x: 0, y: 1};
          else if (dy < 0 && direction.y === 0) nextDirection = {x: 0, y: -1};
        }
      });

      // Initialize
      loadBest();
      draw();
    })();

    // Tic-Tac-Toe (Am≈ëba)
    (function ticTacToe() {
      const boardEl = document.getElementById('tttBoard');
      const statusEl = document.getElementById('tttStatus');
      const resetBtn = document.getElementById('tttReset');
      if (!boardEl || !statusEl || !resetBtn) return;

      const cells = Array.from(boardEl.querySelectorAll('.ttt-cell'));
      const wins = [
        [0,1,2],[3,4,5],[6,7,8],[0,3,6],[1,4,7],[2,5,8],[0,4,8],[2,4,6]
      ];
      let board = ['','','','','','','','',''];
      let turn = 'X';
      let over = false;

      function checkWin() {
        for (const [a, b, c] of wins) {
          if (board[a] && board[a] === board[b] && board[b] === board[c])
            return { win: true, who: board[a], line: [a, b, c] };
        }
        if (board.every(c => c)) return { draw: true };
        return null;
      }

      function setStatus(msg) {
        statusEl.textContent = msg;
      }

      function render() {
        cells.forEach((cell, i) => {
          cell.textContent = board[i];
          cell.classList.remove('x', 'o', 'win');
          if (board[i]) cell.classList.add(board[i].toLowerCase());
        });
      }

      function highlightWin(line) {
        if (line) line.forEach(i => cells[i].classList.add('win'));
      }

      function handleClick(e) {
        const cell = e.target;
        if (!cell.classList.contains('ttt-cell')) return;
        if (over) return;
        const i = parseInt(cell.getAttribute('data-i'), 10);
        if (board[i]) return;

        board[i] = turn;
        render();
        const result = checkWin();

        if (result) {
          over = true;
          if (result.win) {
            setStatus(result.who + ' nyert!');
            highlightWin(result.line);
          } else {
            setStatus('D√∂ntetlen!');
          }
          return;
        }
        turn = turn === 'X' ? 'O' : 'X';
        setStatus(turn + ' k√∂vetkezik');
      }

      function reset() {
        board = ['','','','','','','','',''];
        turn = 'X';
        over = false;
        setStatus('X k√∂vetkezik');
        render();
      }

      boardEl.addEventListener('click', handleClick);
      resetBtn.addEventListener('click', reset);
      render();
    })();
    </script>
</body>
</html>
